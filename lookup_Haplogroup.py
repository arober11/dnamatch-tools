import json
import csv
import sys, getopt
import os

# Purpose:  Attempt to identiy possible Haplogroups, based on an Genotype file from the like of the large to customer providers, or a combined file.
# 
# Status: 
#     GOOD      - Complete set of Matching calls to the leaf
#     UNCERTAIN - Incomplete set of matching calls to the keaf, non cotradicting
#     BAD       - One or more SNP contradicts the tree 
#
# Authour: A. Roberts
# Date:    July 2023
# License: GPLv3. See accompanying LICENSE file.
# No warranty. You are responsible for your use of this program.

snpDict={}
hapDict={}
parDict={}

json_tree_filename='mtDNA-tree-Build-17.json'
snps_filename='mtDNA_SNPS_ToTST.csv'
tree_name='mt-MRCA(RSRS)'
also_possible=0

def script_usage():
  scrpt_name=os.path.basename(sys.argv[0])
  print('')
  print('Purpose:  Attempt to identiy possible haplogroups, based on the mtDNA/yDNA SNPS from a genotype file generated by the large to customer providers, or a combined file')
  print('')
  print('Requires:')
  print('1: A haplotree in JSON format, generated by the like of the mtDNA-tree-to-all.sh, default: "mtDNA-tree-Build-17.json"')
  print('2: A set of SNPS (position,call), in a CSV file, to compare against the haplotree; can be generated by the like of:')
  print('  - mDNA_file_SNPS_in_Haplotree.sh')
  print('  - YDNA_file_SNPS_in_Haplotree.sh')
  print('3: the name of the haplotree, within the JSON file, default "mt-MRCA(RSRS)"')
  print('')
  print('Usage: {} -h|--help -s|--snpfl <SNP_file> -t|--treefl <haplogroup_file> -n|--name <haplotree_name> -p|--possibles'.format(scrpt_name)) 
  print('e.g.')
  print('1: {} -s  <SNP_file> [-t <haplogroup_file> -n <haplotree_name> -p]'.format(scrpt_name)) 
  print('2: {} --snpfl=<SNP_file> [--treefl=<haplogroup_file> --name=<haplotree_name> --possibles]'.format(scrpt_name))
  print('3: {} -h'.format(scrpt_name))
  print('4: {} --help'.format(scrpt_name))
  print('')
  print('e.g.')
  print('python ~/{} -s mtDNA_SNPS_combined.csv  -t mtDNA-tree-Build-17.json -n mt-MRCA(RSRS)'.format(scrpt_name))
  print('')


def search_tree(target, children):
  for haplogroup in children:
    if haplogroup['haplogroup'] == target:
      return haplogroup['haplogroup'] + '<-'
    else:
      if 'children' in haplogroup:
        resultStr=search_tree(target, haplogroup['children'])
        if resultStr <> "":	
          return resultStr + haplogroup['haplogroup'] + '<-'
  return ""


def walk_tree(children, parent, mutOverrideDict):
  for haplogroup in children:
      parDict[haplogroup['haplogroup']]=parent
      if 'children' in haplogroup:
        walk_tree(haplogroup['children'], haplogroup['haplogroup'], mutOverrideDict)
      haplo_status=0
      for mutation in haplogroup["mutations"]:
        call_status=0
        if mutation['descendant']:
          if mutation['posStart']:
            if not (snpDict.get(mutation['posStart']) is None):
              #print(mutation['posStart'],":",snpDict.get(mutation['posStart']),":",mutation['descendant'])
              if snpDict.get(mutation['posStart']) <> mutation['descendant']:
                if (mutOverrideDict.get(mutation['posStart']) is None):
                  call_status=3
                else:
                  call_status=2
              else:
                # Store the match in the Override set
                mutOverrideDict.update({mutation['posStart']:mutation['descendant']})
            else:
              call_status=1
        if call_status > haplo_status:
          haplo_status=call_status
      hapDict[haplogroup["haplogroup"]]=haplo_status
  return 


def check_parents(haplogrp, status):

  if hapDict[haplogrp] > status:
    status=hapDict[haplogrp]

  if status > 2:
    return status
 
  if parDict[haplogrp] <> tree_name:
    status=check_parents(parDict[haplogrp], status)

  return status

def store_longest_string(haplogroup, seartchStr):

  dupList=[]

  #Ignore Anonymous haplogroups
  if "@" in seartchStr:
   return
 
  for dupCheck in resultsDict:
    if seartchStr in resultsDict[dupCheck]:
      return 

  resultsDict.update({haplogroup:seartchStr})
  for dupCheck in resultsDict:
    if haplogroup <> dupCheck and resultsDict[dupCheck] in seartchStr:
      dupList.append(dupCheck)

  for delStr in dupList:
    resultsDict.pop(delStr) 


def main(argv):
   global json_tree_filename
   global snps_filename
   global tree_name
   global also_possible

   try:
      opts, args = getopt.getopt(argv,"hpt:s:n:",["treefl=","snpfl=","name=","help","possibles"])
   except getopt.GetoptError:
      script_usage()
      sys.exit(2)
   for opt, arg in opts:
      if opt in ("-h","--help:"):
         script_usage()
         sys.exit()
      elif opt in ("-t", "--treefl"):
         json_tree_filename = arg
      elif opt in ("-s", "--snpfl"):
         snps_filename = arg
      elif opt in ("-n", "--name"):
         tree_name = arg
      elif opt in ("-p", "--possibles"):
         also_possible = 1

   if not os.path.isfile(json_tree_filename):
     script_usage()
     print('Error - Haplotree file does not exist')
     sys.exit()

   if not os.path.isfile(snps_filename):
     script_usage()
     print('Error - SNPS file does not exist - ' + snps_filename)
     sys.exit()

   if tree_name == "":
     script_usage()
     print('Error - No non blank treename specified')
     sys.exit()

   print('')
   print('Haplotree file: {}'.format(json_tree_filename))
   print('SNPS file:      {}'.format(snps_filename))
   print('Tree name:      {}'.format(tree_name))
   print('')

#-----------------------

if __name__ == "__main__":
   main(sys.argv[1:])

# Opening JSON haplogroup tree file
with open(snps_filename, 'r') as snps_file:
  snp_reader = csv.DictReader(snps_file, fieldnames=['pos','call'])
  for snp_read in snp_reader:
    snpDict[snp_read['pos']]=snp_read['call']

# Opening JSON haplogroup tree file
with open(json_tree_filename, 'r') as haplogroup_tree_file:
  # Reading from json file
  json_object = json.load(haplogroup_tree_file)
  try:
    walk_tree(json_object[tree_name], tree_name, {})
  except: 
    script_usage()
    print('Error: Lookup failed')
    quit(1)

  print('')
  print('Haplogroups the SNP set Satisfy, along with those that the are Possible, though the SNP file is lacking all the necessary calls.') 
  print('')
  print('Haplogroup = State')
  good=0       # Status 0
  uncertain=0  # Status 1
  overridden=0 # Status 2
  bad=0        # Stasus 3
  total=0
  resultsDict={}
  for haplogroup in hapDict:
    total+=1
    status=hapDict[haplogroup]
    if status < 3:
      leafStatus=status
      status=check_parents(haplogroup, status)
      if status > 2:
        bad+=1
      else:
        status=leafStatus
        if status == 0:
          good+=1
          seartchStr=search_tree(haplogroup, json_object[tree_name]) + tree_name + ' - Satisfied'
          store_longest_string(haplogroup, seartchStr)
        elif status == 1:
          uncertain+=1
          if also_possible:
            seartchStr=search_tree(haplogroup, json_object[tree_name]) + tree_name + ' - Possible'
            store_longest_string(haplogroup, seartchStr)
        elif status == 2:
          overridden+=1
    else:
      bad+=1

  if good > 0 or uncertain > 0:
      print('======================================================')
      print('Satisfied:')
      for haplogroup in resultsDict:
        if 'Satisfied' in resultsDict[haplogroup]:
          print('')
          print(resultsDict[haplogroup])
      print('')
      if also_possible:
        print('------------------------------------------------------')
        print('Possible:')
        for haplogroup in resultsDict:
          if 'Possible' in resultsDict[haplogroup]:
            print('')
            print(resultsDict[haplogroup])
      print('======================================================')
      print('')

  print('Possibly Satisfied: {}  Missing Calls: {}  Overridden downstream: {}  Bad: {}  Total: {}'.format(good, uncertain, overridden, bad, total)) 
quit()
